---
layout: post
title:  "编译系统透视读书笔记（2）"
date: 2020-05-20 08:50:15 +0000   
---

第四章 语法树到目标代码
------

* 为了避免为每一种 CPU 去写一套完全独立的后端这种情况以及便于优化，于是在语法树和包含机器特征的目标代码之间建立了一种中间结构，这样就能更方便地将语法树转换为适合不同 CPU 的目标代码。
* 高端 gimple，低端 gimple，cfg，ssa，RTL 就是这样的中间结构。
* RTL 数据已经开始体现出硬件平台的相关性。同一段源代码为两种不同硬件平台编译的程序，在低端 gimple 结构中还是一致的，在 RTL 数据中开始出现差别。
* gcc/cgraphunit.c
    - cgraph_analyze_functions ?
	- cgraph_analyze_function ?		-> cgraph_node::analyze
* gcc/gimplify.c
    - gimplify_function_tree 	根据函数的语法树生成对应的中间结构
	- gimplify_body
	- gimplify_stmt
	- gimplify_expr 			实质处理
	- gimplify_bind_expr
	- gimplify_build_bind		生成 BIMPLE_BIND 节点
	- gimplify_bind_set_vars	继承语法树中的变量节点至 vars
	- gimplify_bind_set_body	挂接 body，此时 body 还没有内容，后面会调用 gimplify_stmt 填充 body
	- gimplify_stmt_list
	- gimplify_decl_expr
	- gimplify_modify_expr